<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Merry Christmas WebGL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
      body { margin: 0; overflow: hidden; background-color: #000; }
      .font-cursive { font-family: 'Great Vibes', cursive; }
      .font-sans { font-family: 'Inter', sans-serif; }
    </style>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
    "zustand": "https://esm.sh/zustand@4.5.0?external=react",
    "gsap": "https://esm.sh/gsap@3.12.5",
    "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.12",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>
    <script type="module">
        import React, { useState, useEffect, useRef, useMemo, Suspense } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { OrbitControls, Stars, Sparkles, Environment, Float, Html } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';
        import { create } from 'zustand';
        import gsap from 'gsap';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- CONSTANTS & TYPES ---
        const AppPhase = {
            Tree: 'tree',
            Blooming: 'blooming',
            Nebula: 'nebula',
            Collapsing: 'collapsing'
        };

        const HandGesture = {
            None: 'None',
            Open_Palm: 'Open_Palm',
            Closed_Fist: 'Closed_Fist'
        };

        const ORNAMENT_COLORS = [
            '#C5A059', // Antique Gold
            '#800020', // Burgundy
            '#778899', // Slate Gray/Blue
            '#B76E79', // Rose Gold
            '#F7E7CE', // Champagne
        ];

        // --- UTILS (Geometry) ---
        const generateTreePoints = (count, radius, height) => {
            const points = [];
            for (let i = 0; i < count; i++) {
                const yNorm = Math.random();
                const y = (yNorm - 0.5) * height;
                const r = (1 - yNorm) * radius;
                const theta = Math.random() * Math.PI * 2;
                const rRandom = r * Math.sqrt(Math.random()); 
                const x = rRandom * Math.cos(theta);
                const z = rRandom * Math.sin(theta);
                points.push(x, y, z);
            }
            return points;
        };

        const generateGarlandPoints = (count, radius, height, turns = 5, spread = 0.3) => {
            const points = [];
            for (let i = 0; i < count; i++) {
                const t = i / count;
                const yBase = (t - 0.5) * height;
                const currentRadius = (1 - t) * radius;
                const angle = t * Math.PI * 2 * turns;
                const xBase = currentRadius * Math.cos(angle);
                const zBase = currentRadius * Math.sin(angle);
                
                const rndTheta = Math.random() * Math.PI * 2;
                const rndPhi = Math.random() * Math.PI;
                const rndR = Math.random() * spread;
                
                const xOff = rndR * Math.sin(rndPhi) * Math.cos(rndTheta);
                const yOff = rndR * Math.sin(rndPhi) * Math.sin(rndTheta);
                const zOff = rndR * Math.cos(rndPhi);
                
                points.push(xBase + xOff, yBase + yOff, zBase + zOff);
            }
            return points;
        };

        const generateNebulaPoints = (count, radius, tube) => {
            const points = [];
            for (let i = 0; i < count; i++) {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                const x = (radius + tube * Math.cos(v)) * Math.cos(u);
                const y = tube * Math.sin(v);
                const z = (radius + tube * Math.cos(v)) * Math.sin(u);
                points.push(x, y, z);
            }
            return points;
        };

        const generateTorusPoints = (count, radius, tubeRadius) => {
            const points = [];
            for (let i = 0; i < count; i++) {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                const x = (radius + tubeRadius * Math.cos(v)) * Math.cos(u);
                const y = (tubeRadius * Math.sin(v)) * 0.2; 
                const z = (radius + tubeRadius * Math.cos(v)) * Math.sin(u);
                points.push(x, y, z);
            }
            return points;
        };

        // --- STORE ---
        const useStore = create((set) => ({
            phase: AppPhase.Tree,
            gesture: HandGesture.None,
            isCameraOpen: false,
            setPhase: (phase) => set({ phase }),
            setGesture: (gesture) => set({ gesture }),
            toggleCamera: () => set((state) => ({ isCameraOpen: !state.isCameraOpen })),
        }));

        // --- COMPONENTS ---

        // HandTracker Component
        const HandTracker = () => {
            const videoRef = useRef(null);
            const { isCameraOpen, setGesture } = useStore();
            const [loaded, setLoaded] = useState(false);
            const landmarkerRef = useRef(null);
            const requestRef = useRef();

            useEffect(() => {
                const initLandmarker = async () => {
                    try {
                        const vision = await FilesetResolver.forVisionTasks(
                            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.12/wasm"
                        );
                        landmarkerRef.current = await HandLandmarker.createFromOptions(vision, {
                            baseOptions: {
                                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                                delegate: "GPU"
                            },
                            runningMode: "VIDEO",
                            numHands: 1
                        });
                        setLoaded(true);
                    } catch (error) {
                        console.error("Error loading MediaPipe:", error);
                    }
                };
                initLandmarker();
            }, []);

            const detectGesture = (landmarks) => {
                if (!landmarks || landmarks.length === 0) return HandGesture.None;
                
                const hand = landmarks[0];
                const tips = [8, 12, 16, 20];
                const pips = [6, 10, 14, 18];
                let extendedFingers = 0;
                
                for (let i = 0; i < 4; i++) {
                    if (hand[tips[i]].y < hand[pips[i]].y) {
                        extendedFingers++;
                    }
                }

                if (extendedFingers >= 4) return HandGesture.Open_Palm;
                if (extendedFingers <= 1) return HandGesture.Closed_Fist;

                return HandGesture.None;
            };

            const predict = () => {
                if (landmarkerRef.current && videoRef.current && videoRef.current.readyState >= 2) {
                    const results = landmarkerRef.current.detectForVideo(videoRef.current, performance.now());
                    if (results.landmarks) {
                        const detected = detectGesture(results.landmarks);
                        setGesture(detected);
                    }
                }
                requestRef.current = requestAnimationFrame(predict);
            };

            useEffect(() => {
                if (isCameraOpen && loaded) {
                    const startCamera = async () => {
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                            if (videoRef.current) {
                                videoRef.current.srcObject = stream;
                                videoRef.current.addEventListener('loadeddata', predict);
                            }
                        } catch (err) {
                            console.error("Camera access denied:", err);
                        }
                    };
                    startCamera();
                } else {
                    if (videoRef.current && videoRef.current.srcObject) {
                        const stream = videoRef.current.srcObject;
                        stream.getTracks().forEach(track => track.stop());
                        videoRef.current.srcObject = null;
                    }
                    if (requestRef.current) {
                        cancelAnimationFrame(requestRef.current);
                    }
                }

                return () => {
                   if (requestRef.current) cancelAnimationFrame(requestRef.current);
                };
            }, [isCameraOpen, loaded]);

            if (!isCameraOpen) return null;

            return React.createElement('div', { className: "absolute top-4 right-4 w-48 h-36 bg-white/10 backdrop-blur-md rounded-xl overflow-hidden border border-white/20 shadow-lg z-50" },
                React.createElement('video', {
                    ref: videoRef,
                    autoPlay: true,
                    playsInline: true,
                    className: "w-full h-full object-cover transform -scale-x-100"
                }),
                !loaded && React.createElement('div', { className: "absolute inset-0 flex items-center justify-center text-xs text-white" }, "Loading Model...")
            );
        };

        // ChristmasTree Component
        const ChristmasTree = () => {
            const meshRef = useRef(null);
            const garlandMeshRef = useRef(null);
            const dummy = useMemo(() => new THREE.Object3D(), []);
            
            const { phase, setPhase, gesture } = useStore();
            const [hoveredPoint, setHoveredPoint] = useState(null);

            const PARTICLE_COUNT = 5000;
            const GARLAND_PARTICLE_COUNT = 2000;
            const TREE_HEIGHT = 10;
            const TREE_RADIUS = 3.5;
            const NEBULA_RADIUS = 8;
            const NEBULA_TUBE = 2;

            const { 
                treeData, nebulaData, colors,
                garlandTreeData, garlandNebulaData, garlandColors, garlandTypes 
            } = useMemo(() => {
                const tPoints = generateTreePoints(PARTICLE_COUNT, TREE_RADIUS, TREE_HEIGHT);
                const nPoints = generateNebulaPoints(PARTICLE_COUNT, NEBULA_RADIUS, NEBULA_TUBE);
                const cData = new Float32Array(PARTICLE_COUNT * 3);
                const tempColor = new THREE.Color();

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const isOrnament = Math.random() > 0.9;
                    if (isOrnament) {
                        tempColor.set(ORNAMENT_COLORS[Math.floor(Math.random() * ORNAMENT_COLORS.length)]);
                    } else {
                        tempColor.set('#2E8B57').lerp(new THREE.Color('#006400'), Math.random());
                    }
                    cData[i * 3] = tempColor.r;
                    cData[i * 3 + 1] = tempColor.g;
                    cData[i * 3 + 2] = tempColor.b;
                }

                const gTreePoints = generateGarlandPoints(GARLAND_PARTICLE_COUNT, TREE_RADIUS + 0.2, TREE_HEIGHT, 6, 0.25);
                const gNebulaPoints = generateTorusPoints(GARLAND_PARTICLE_COUNT, NEBULA_RADIUS + 4, 0.5); 
                
                const gColors = new Float32Array(GARLAND_PARTICLE_COUNT * 3);
                const gTypes = new Float32Array(GARLAND_PARTICLE_COUNT);

                const gold = new THREE.Color('#FFD700');
                const warmWhite = new THREE.Color('#FFF8E7');
                
                for (let i = 0; i < GARLAND_PARTICLE_COUNT; i++) {
                    const isLight = Math.random() > 0.85;
                    gTypes[i] = isLight ? 1 : 0;

                    let c;
                    if (isLight) {
                        c = warmWhite;
                    } else {
                        c = gold.clone().offsetHSL(0, 0, (Math.random() - 0.5) * 0.3);
                    }
                    
                    gColors[i * 3] = c.r;
                    gColors[i * 3 + 1] = c.g;
                    gColors[i * 3 + 2] = c.b;
                }

                return {
                    treeData: tPoints,
                    nebulaData: nPoints,
                    colors: cData,
                    garlandTreeData: gTreePoints,
                    garlandNebulaData: gNebulaPoints,
                    garlandColors: gColors,
                    garlandTypes: gTypes
                };
            }, []);

            const animState = useRef({ progress: 0 });

            useEffect(() => {
                if (phase === AppPhase.Blooming) {
                    gsap.to(animState.current, {
                        progress: 1,
                        duration: 2.5,
                        ease: 'elastic.out(1, 0.5)',
                        onComplete: () => setPhase(AppPhase.Nebula)
                    });
                } else if (phase === AppPhase.Collapsing) {
                    gsap.to(animState.current, {
                        progress: 0,
                        duration: 2,
                        ease: 'power3.inOut',
                        onComplete: () => setPhase(AppPhase.Tree)
                    });
                }
            }, [phase, setPhase]);

            useEffect(() => {
                if (gesture === HandGesture.Open_Palm && phase === AppPhase.Tree) {
                    setPhase(AppPhase.Blooming);
                } else if (gesture === HandGesture.Closed_Fist && phase === AppPhase.Nebula) {
                    setPhase(AppPhase.Collapsing);
                }
            }, [gesture, phase, setPhase]);

            const handlePointerMove = (e) => {
                if (phase === AppPhase.Tree) {
                    setHoveredPoint(e.point);
                }
            };

            const handlePointerLeave = () => {
                setHoveredPoint(null);
            };

            useFrame((state) => {
                const time = state.clock.getElapsedTime();
                const progress = animState.current.progress;

                // Update Tree
                if (meshRef.current) {
                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        const idx = i * 3;
                        let tx = treeData[idx];
                        let ty = treeData[idx + 1];
                        let tz = treeData[idx + 2];
                        const nx = nebulaData[idx];
                        const ny = nebulaData[idx + 1];
                        const nz = nebulaData[idx + 2];

                        let x = THREE.MathUtils.lerp(tx, nx, progress);
                        let y = THREE.MathUtils.lerp(ty, ny, progress);
                        let z = THREE.MathUtils.lerp(tz, nz, progress);

                        y += Math.sin(time * 0.5 + x * 0.5) * 0.1;

                        if (progress < 0.1 && hoveredPoint) {
                            const dx = x - hoveredPoint.x;
                            const dy = y - hoveredPoint.y;
                            const dz = z - hoveredPoint.z;
                            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            const repulsionRadius = 2.0;
                            if (dist < repulsionRadius) {
                                const force = (repulsionRadius - dist) / repulsionRadius;
                                x += dx * force * 1.5;
                                y += dy * force * 1.5;
                                z += dz * force * 1.5;
                            }
                        }

                        if (progress > 0.9) {
                            const angle = time * 0.1;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            const rx = x * cos - z * sin;
                            const rz = x * sin + z * cos;
                            x = rx;
                            z = rz;
                        }

                        dummy.position.set(x, y, z);
                        const scale = 1 + Math.sin(time * 2 + i) * 0.2 + (progress === 1 ? 0.5 : 0);
                        dummy.scale.set(scale, scale, scale);
                        dummy.updateMatrix();
                        meshRef.current.setMatrixAt(i, dummy.matrix);
                    }
                    meshRef.current.instanceMatrix.needsUpdate = true;
                    if (phase === AppPhase.Tree) {
                        meshRef.current.rotation.y = time * 0.05;
                    } else {
                        meshRef.current.rotation.y = 0;
                    }
                }

                // Update Garland
                if (garlandMeshRef.current) {
                    for (let i = 0; i < GARLAND_PARTICLE_COUNT; i++) {
                        const idx = i * 3;
                        const tx = garlandTreeData[idx];
                        const ty = garlandTreeData[idx + 1];
                        const tz = garlandTreeData[idx + 2];
                        const nx = garlandNebulaData[idx];
                        const ny = garlandNebulaData[idx + 1];
                        const nz = garlandNebulaData[idx + 2];

                        let x = THREE.MathUtils.lerp(tx, nx, progress);
                        let y = THREE.MathUtils.lerp(ty, ny, progress);
                        let z = THREE.MathUtils.lerp(tz, nz, progress);

                        if (progress < 0.1 && hoveredPoint) {
                            const dx = x - hoveredPoint.x;
                            const dy = y - hoveredPoint.y;
                            const dz = z - hoveredPoint.z;
                            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            if (dist < 2.5) {
                                const force = (2.5 - dist) / 2.5;
                                x += dx * force * 1.2;
                                y += dy * force * 1.2;
                                z += dz * force * 1.2;
                            }
                        }

                        if (progress > 0.9) {
                            const angle = time * 0.15;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);
                            const rx = x * cos - z * sin;
                            const rz = x * sin + z * cos;
                            x = rx;
                            z = rz;
                        }

                        dummy.position.set(x, y, z);
                        const isLight = garlandTypes[i] === 1;
                        if (isLight) {
                            const twinkle = Math.sin(time * 3 + i * 10) * 0.5 + 0.5;
                            const scale = 1.0 + twinkle * 1.5 + (progress === 1 ? 0.5 : 0);
                            dummy.scale.set(scale, scale, scale);
                        } else {
                            const glitter = Math.sin(time * 10 + i) * 0.3 + 0.7;
                            const scale = 0.6 * glitter + (progress === 1 ? 0.3 : 0);
                            dummy.scale.set(scale, scale, scale);
                        }
                        dummy.updateMatrix();
                        garlandMeshRef.current.setMatrixAt(i, dummy.matrix);
                    }
                    garlandMeshRef.current.instanceMatrix.needsUpdate = true;
                    if (phase === AppPhase.Tree) {
                        garlandMeshRef.current.rotation.y = time * 0.05;
                    } else {
                        garlandMeshRef.current.rotation.y = 0;
                    }
                }
            });

            return React.createElement('group', null,
                React.createElement('instancedMesh', {
                    ref: meshRef,
                    args: [undefined, undefined, PARTICLE_COUNT],
                    onPointerMove: handlePointerMove,
                    onPointerLeave: handlePointerLeave
                },
                    React.createElement('sphereGeometry', { args: [0.08, 8, 8] },
                        React.createElement('instancedBufferAttribute', {
                            attach: "attributes-color",
                            args: [colors, 3]
                        })
                    ),
                    React.createElement('meshStandardMaterial', {
                        vertexColors: true,
                        roughness: 0.4,
                        metalness: 0.6,
                        emissive: "#111",
                        emissiveIntensity: 0.2
                    })
                ),
                React.createElement('instancedMesh', {
                    ref: garlandMeshRef,
                    args: [undefined, undefined, GARLAND_PARTICLE_COUNT]
                },
                    React.createElement('sphereGeometry', { args: [0.07, 8, 8] },
                        React.createElement('instancedBufferAttribute', {
                            attach: "attributes-color",
                            args: [garlandColors, 3]
                        })
                    ),
                    React.createElement('meshStandardMaterial', {
                        vertexColors: true,
                        roughness: 0.1,
                        metalness: 0.9,
                        emissive: "#FFD700",
                        emissiveIntensity: 0.8,
                        toneMapped: false
                    })
                )
            );
        };

        // UI Component
        const UI = () => {
            const { phase, gesture, toggleCamera, isCameraOpen } = useStore();

            return React.createElement('div', { className: "absolute inset-0 pointer-events-none z-10 flex flex-col justify-between p-6" },
                React.createElement('div', { className: "flex flex-col gap-4 items-start" },
                    React.createElement('div', { className: "bg-white/10 backdrop-blur-md rounded-lg p-4 border border-white/10 text-white w-64" },
                        React.createElement('div', { className: "text-xs uppercase tracking-widest opacity-50 mb-1" }, "Status"),
                        React.createElement('div', { className: "flex items-center gap-2" },
                            React.createElement('div', { className: `w-2 h-2 rounded-full ${gesture !== 'None' ? 'bg-green-400 animate-pulse' : 'bg-gray-400'}` }),
                            React.createElement('span', { className: "font-bold text-sm" }, `Phase: ${phase.toUpperCase()}`)
                        ),
                        React.createElement('div', { className: "mt-2 text-xs opacity-70" },
                            "Detected: ",
                            React.createElement('span', { className: "font-mono text-yellow-300" }, gesture)
                        )
                    ),
                    React.createElement('button', {
                        onClick: toggleCamera,
                        className: "pointer-events-auto bg-white/10 hover:bg-white/20 backdrop-blur-md border border-white/20 text-white text-xs px-4 py-2 rounded-full transition-all flex items-center gap-2"
                    },
                        React.createElement('span', { className: `w-2 h-2 rounded-full ${isCameraOpen ? 'bg-red-500' : 'bg-green-500'}` }),
                        isCameraOpen ? 'CLOSE CAMERA' : 'OPEN CAMERA'
                    ),
                    React.createElement('div', { className: "text-white/60 text-xs max-w-xs space-y-1" },
                        React.createElement('p', null, "ðŸ‘‹ ", React.createElement('span', { className: "text-white font-bold" }, "Open Palm"), " to Explode/Blooom"),
                        React.createElement('p', null, "âœŠ ", React.createElement('span', { className: "text-white font-bold" }, "Closed Fist"), " to Reset Tree")
                    )
                ),
                React.createElement('div', { className: "absolute inset-0 flex items-center justify-center pointer-events-none select-none" },
                    React.createElement('h1', { className: "text-6xl md:text-9xl text-transparent bg-clip-text bg-gradient-to-b from-yellow-200 to-yellow-600 font-cursive drop-shadow-[0_0_15px_rgba(253,224,71,0.5)] animate-pulse opacity-80" }, "Merry Christmas")
                ),
                React.createElement('div', { className: "self-center pointer-events-auto" },
                    React.createElement('div', { className: "bg-black/30 backdrop-blur-xl border border-white/10 rounded-full px-6 py-3 flex items-center gap-4 text-white hover:bg-black/40 transition-colors cursor-pointer group" },
                        React.createElement('div', { className: "w-8 h-8 rounded-full bg-gradient-to-tr from-cyan-300 to-blue-500 flex items-center justify-center animate-[spin_4s_linear_infinite] group-hover:shadow-[0_0_10px_rgba(34,211,238,0.5)]" }, "â„ï¸"),
                        React.createElement('div', { className: "flex flex-col" },
                            React.createElement('span', { className: "text-xs text-cyan-200" }, "Now Playing"),
                            React.createElement('div', { className: "w-32 overflow-hidden whitespace-nowrap" },
                                React.createElement('span', { className: "text-sm font-semibold inline-block animate-[marquee_5s_linear_infinite]" }, "Merry Christmas Mr. Lawrence - Sakamoto")
                            )
                        ),
                        React.createElement('div', { className: "flex gap-1 items-end h-4" },
                            React.createElement('div', { className: "w-1 bg-green-400 h-2 animate-[music_1s_ease-in-out_infinite]" }),
                            React.createElement('div', { className: "w-1 bg-green-400 h-4 animate-[music_1.2s_ease-in-out_infinite_0.1s]" }),
                            React.createElement('div', { className: "w-1 bg-green-400 h-3 animate-[music_0.8s_ease-in-out_infinite_0.2s]" })
                        )
                    )
                ),
                React.createElement('style', null, `
                    @keyframes marquee {
                        0% { transform: translateX(100%); }
                        100% { transform: translateX(-100%); }
                    }
                    @keyframes music {
                        0%, 100% { height: 4px; }
                        50% { height: 100%; }
                    }
                `)
            );
        };

        // Scene Component
        const Scene = () => {
            return React.createElement(Canvas, {
                camera: { position: [0, 2, 15], fov: 45 },
                gl: { antialias: false, alpha: false }
            },
                React.createElement('color', { attach: "background", args: ['#050505'] }),
                React.createElement('ambientLight', { intensity: 0.5 }),
                React.createElement('pointLight', { position: [10, 10, 10], intensity: 1.5, color: "#ffaa00" }),
                React.createElement('pointLight', { position: [-10, 5, -10], intensity: 1, color: "#4455ff" }),
                React.createElement('spotLight', {
                    position: [0, 15, 0],
                    angle: 0.5,
                    penumbra: 1,
                    intensity: 2,
                    color: "#fff",
                    castShadow: true
                }),
                React.createElement(Suspense, { fallback: React.createElement(Html, { center: true }, "Loading 3D Assets...") },
                    React.createElement(Environment, { preset: "city" }),
                    React.createElement(Stars, { radius: 100, depth: 50, count: 5000, factor: 4, saturation: 0, fade: true, speed: 1 }),
                    React.createElement(Sparkles, { count: 200, scale: 12, size: 2, speed: 0.4, opacity: 0.5, color: "#ffd700" }),
                    React.createElement('group', { position: [0, -4, 0] },
                        React.createElement(ChristmasTree),
                        React.createElement(Float, { speed: 2, rotationIntensity: 0.5, floatIntensity: 0.5 },
                            React.createElement('mesh', { position: [0, 10.2, 0] },
                                React.createElement('octahedronGeometry', { args: [0.8, 0] }),
                                React.createElement('meshStandardMaterial', { color: "#fff", emissive: "#fff", emissiveIntensity: 4 })
                            )
                        )
                    )
                ),
                React.createElement(OrbitControls, {
                    enablePan: false,
                    enableZoom: true,
                    maxPolarAngle: Math.PI / 1.5,
                    minPolarAngle: Math.PI / 3
                }),
                React.createElement(EffectComposer, { disableNormalPass: true },
                    React.createElement(Bloom, { luminanceThreshold: 1, mipmapBlur: true, intensity: 1.5, radius: 0.6 }),
                    React.createElement(Vignette, { eskil: false, offset: 0.1, darkness: 1.1 })
                )
            );
        };

        // App Component
        const App = () => {
            return React.createElement('div', { className: "relative w-full h-screen bg-black overflow-hidden font-sans" },
                React.createElement(Scene),
                React.createElement(UI),
                React.createElement(HandTracker)
            );
        };

        // --- ROOT ---
        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        root.render(React.createElement(App));

    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>